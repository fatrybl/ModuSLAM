Алгоритм автоматического создания графа.

Понятия:
    1) "батч" - набор измерений из хендлеров.
    1) "кластер" - список измерений в промежутке времени [T1, T2] и временем t = median(Z).
    2) "связь" - структура, хранящей в себе 2 связанных кластера.
    3) "кандидат" - список кластеров с дополнительными свойствами.
    4) "граф-кандидат" - копия G_t-1 (исходного графа) и собственный Gt.
    5) "Gt" - список рёбер для добавления в граф, база данных BD_t с новыми вершинами.

Соединительная часть
===========================================================================================
1) Получаем измерения от датчиков и обрабатываем их в соответствующих хендлерах.

2) Создаем батч измерений, накапливая их из хендлеров, пока не активируется критерий остановки.


Независимая часть
============================================================================================

=======Если есть преинтегрируемые измерения===========================

1) Формируем отсортированные по времени списки дискретных измерений и преинтегрируемых измерений.

2) Если в дискретных измерениях есть одометрия, обе части которой в рамках батча,
   дробим ее на 2 отдельных измерения.

3) Формируем список вариантов V всевозможных комбинаций кластеров из списка дискретных изменений.

4) Для каждой Vi из V формируем комбинации пар (ClustersWithConnections), используя преинтегрир. измерения.

5) Фильтруем варианты V с учетом осуществимости связей.

Отрисовка кандидатов: отрисовываем каждый ClustersWithConnections.

6) Формируем список комбинаций кластеров с учётом преинт.измерений:
    Для каждой пары:
        из преинт. измерений формируем дискретные и добавляем в соотв. кластер.

      Те пре-инт. измерения, которые никуда не попали, запоминаем, формируя ClustersWithLeftovers.

7) Отдельно обрабатываем ситуацию, когда 1 кластер со всеми измерения внутри.
   Получаем список наборов кластеров с неиспользованными измерениями.

8) область поиска вершин: DB = DB_t-1 + DB_t, DB_t-1 = const, DB_t = dynamic.

    Для каждого набора Vi из V:
        1) Для Сj из Vi:
                Для Zk из Сj:
                    1) Zj -> EdgeFactory (EF).
                    2)
                        2.1) EF содержит искомые и неискомые вершины.
                            Создаем сразу неискомые, запоминаем.
                        2.2) Ищем искомые в DB, добавляем в ребро.
                        2.3) Создаём ненайденные искомые, запоминаем.
                        2.4) Кладём вновь возданные вершины в DB_t.

        2) Для Сi из DB_t:
            2.1) скрещиваем вершины одно типа.
            2.2) заменяем их в рёбрах.

        3) Получаем новую DB_t.


9) Оцениваем каждого граф-кандидата отдельно.
10) Выбираем лучшего граф-кандидата.
11) Заменяем исходный граф новым, прорешиваем.
12) Неиспользованные преинт.измерения кладём в хранилище измерений на следующий этап.


=======Если нет преинтегрируемых измерений===========================

1) Формируем отсортированный по времени список дискретных измерений.

2) Если в дискретных измерениях есть одометрия, начало которой в рамках кандидата,
   дробим его на 2 вершины и добавляем к дискретным измерениям.

3) Формируем список вариантов V всевозможных комбинаций кластеров из списка дискретных изменений.

Отрисовка кандидатов: рисуем каждый вариант как отдельный граф без связей (только вершины).

4) область поиска вершин: DB = DB_t-1 + DB_t, DB_t-1 = const, DB_t = dynamic.

    Для каждого набора Vi из V:
        1) Для Сj из Vi:
                Для Zk из Сj:
                    1) Zj -> EdgeFactory (EF).
                    2)
                        2.1) EF содержит искомые и неискомые вершины.
                            Создаем сразу неискомые, запоминаем.
                        2.2) Ищем искомые в DB, добавляем в ребро.
                        2.3) Создаём ненайденные искомые, запоминаем.
                        2.4) Кладём вновь возданные вершины в DB_t.

        2) Для Сi из DB_t:
            2.1) скрещиваем вершины одно типа.
            2.2) заменяем их в рёбрах.

        3) Получаем новую DB_t.


5) Оцениваем каждого граф-кандидата отдельно.
6) Выбираем лучшего граф-кандидата.
7) Заменяем исходный граф новым, прорешиваем.
